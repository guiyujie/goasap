/** * Copyright (c) 2007 Moses Gunesch *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */package org.goasap.items {	import flash.utils.getTimer;		import org.goasap.GoEngine;	import org.goasap.events.GoEvent;	import org.goasap.interfaces.IPlayable;	import org.goasap.interfaces.IUpdatable;		/**	 * Dispatched just prior to an animation's first update after the delay 	 * has completed, if one was set. Any number of callbacks may also be 	 * associated with this cycle using <code>addCallback</code>.	 * @eventType org.goasap.events.START	 */	[Event(name="START", type="org.goasap.events.GoEvent")]	/**	 * Dispatched on the animation's update pulse. Any number of callbacks	 * may also be associated with this cycle using <code>addCallback</code>.	 * @eventType org.goasap.events.UPDATE	 */	[Event(name="UPDATE", type="org.goasap.events.GoEvent")]	/**	 * Dispatched if an animation is manually stopped. Any number of callbacks	 * may also be associated with this cycle using <code>addCallback</code>.	 * @eventType org.goasap.events.STOP	 */	[Event(name="STOP", type="org.goasap.events.GoEvent")]	/**	 * Dispatched on an animation's final update, just after the last update event.	 * Any number of callbacks may also be associated with this cycle using <code>addCallback</code>.	 * @eventType org.goasap.events.COMPLETE	 */	[Event(name="COMPLETE", type="org.goasap.events.GoEvent")]	/**	 * LinearGo extends the base class GoItem to define a playable A-to-B animation. 	 * 	 * <p><b>LinearGo: A very simple tween</b></p>	 * 	 * <p>A LinearGo instance is a playable object that animates a single number. It dispatches events 	 * and callbacks associated with the animation's start, update and completion. Instances can be used 	 * directly, or easily subclassed to build custom tweening APIs. LinearGo extends GoItem, which 	 * provides basic settings shared by physics and tween items. These include play-state contants and 	 * a <code>state</code> property, <code>pulseInterval</code>, and the two common animation options 	 * <code>useRounding</code> and <code>useRelative</code>.</p>	 * 	 * <p>The tween can be customized using the instance properties <code>duration</code>, <code>easing</code> 	 * and <code>delay</code>. The number crunched by a LinearGo is readable in its <code>position</code> 	 * property. This number always starts at 0 and completes at 1, regardless of the tween's duration 	 * or easing (those parameters are factored in to produce accurate fractional in-between values).  	 * As the tween runs, you can use <code>position</code> as a multiplier to animate virtually anything: 	 * motion, alpha, a sound level, the values in a ColorTransform, BitmapFilter, a 3D scene, and so on.	 * Note that at times position may be less than 0 or greater than 1 depending on the easing function.</p>	 * 	 * <p>The START event occurs just before the first update (after the delay). UPDATE is fired once on 	 * <i>every</i> update pulse, and COMPLETE just after the final update. The STOP event, more common in 	 * physics animation, is fired by LinearGo only if a tween is stopped before it completes. Besides using	 * standard events, you can store callback functions (method-closures) using <code>addCallback</code>.	 * Any number of callbacks can be associated with each GoEvent type. This alternative to the standard event 	 * model was included in LinearGo since it's a common feature of many modern tweening APIs, and very 	 * slightly more efficient than standard events.</p>	 * 	 * <p><b>Subclassing to create custom tweens</b></p>	 * 	 * <p><i>Important: Store your custom tween classes in a package bearing your own classpath, not in the core 	 * package! This will help avoid confusion with other authors' work.</i></p>	 * 	 * <p>It's possible to build virtually any tweening API over LinearGo because all of the specifics are left 	 * up to you: target objects, tweenable properties, tween values — and importantly, the datatypes of all of these. 	 * </p>	 * 	 * <p>A basic subclass can be created in three steps: Gathering target & property information, subclassing the 	 * <code>start</code> method to set up the tween, and finally subclassing the <code>onUpdate</code> method 	 * to affect the tween. The first step, gathering tween target and property information, can be done by writing 	 * getter/setter properties, customizing the constructor, or both. Consider various options such as allowing for 	 * single vs. multiple target objects, open vs. specific tween properties, and so on. The next step, subclassing 	 * <code>start</code>, involves figuring the tween's amount of change and implementing a standard Go convention, 	 * <code>useRelative</code>. This option should enable the user to declare tween values as relative to existing 	 * values instead of as fixed absolutes. In the final step, you subclass <code>onUpdate</code> to apply the tween, 	 * using the <code>_position</code> calculated by this base class:</p>	 * 	 * <pre>target[ propName ] = super.correctValue(start + change * _position);</pre>	 * 	 * <p>The helper method <code>correctValue</code> is provided in the superclass GoItem, to clean up NaN values 	 * and apply rounding when <code>useRounding</code> is activated. That's it — events and callbacks are 	 * dispatched by LinearGo, so subclasses can remain simple.</p>	 * 	 * <p>An optional fourth step will make your custom tween compatible with Go managers. To do this, implement 	 * the IManageable interface. (OverlapMonitor prevents different tween instances from handling the same 	 * property at once; you can build other managers as well.)</p>	 * 	 * {In the game of Go a black or white stone is called a go-ishi.}	 * 	 * @author Moses Gunesch	 */	public class LinearGo extends GoItem implements IPlayable, IUpdatable	{		// -== Settable Class Defaults ==-				/**		 * Class default for the instance property delay.		 * @default 0		 * @see #delay		 */		public static var defaultDelay : Number = 0;				/**		 * Class default for the instance property duration.		 * @default 1		 * @see #duration		 */		public static var defaultDuration : Number = 1;				/**		 * Class default for the instance property easing. 		 * @default fl.motion.easing.Quintic.easeOut		 * @see #easing		 */		public static var defaultEasing:Function = function(t:Number, b:Number, c:Number, d:Number) : Number {			return c * ((t = t / d - 1) * t * t * t * t + 1) + b;		};				// -== Pulic Properties ==-				/**		 * Number of seconds after start() call that the LinearGo begins processing.		 * <p>If not set manually, the class default defaultDelay is adopted.</p>		 * @see #defaultDelay		 */		public function get delay():Number {			return _delay;		}		public function set delay(seconds:Number):void {			if (_state==STOPPED && seconds >= 0) {				_delay = seconds;			}		}				/**		 * Number of seconds the LinearGo takes to process.		 * <p>If not set manually, the class default defaultDuration is adopted.</p>		 * @see #defaultDuration		 */		public function get duration():Number {			return _duration;		}		public function set duration(seconds:Number):void {			if (_state==STOPPED && seconds >= 0) {				_duration = seconds;			}		}				/**		 * Any standard easing-equation function such as the ones found in		 * the Flash package fl.motion.easing or the flex package mx.effects.easing.		 * 		 * <p>If not set manually, the class default defaultEasing is adopted. An error		 * is thrown if the function does not follow the typical format. For easings 		 * that accept more than four parameters use <code>extraEasingParams</code>.		 * </p>		 * 		 * @see #defaultEasing		 * @see #extraEasingParams		 */		public function get easing():Function {			return _easing;		}		public function set easing(type:Function):void {			if (_state==STOPPED) {				try {					if (type(1,1,1,1) is Number) {						_easing = type;					}				}				catch (e:Error) {					throw e;				}			}		}				/**		 * Additional parameters to pass to easing functions that accept more than four.		 * @see #easing		 */		public function get extraEasingParams() : Array {			return _extraEaseParams;		}		public function set extraEasingParams(params:Array):void {			if (_state==STOPPED && params is Array && params.length>0) {				_extraEaseParams = params;			}		}				/**		 * Makes a tween cycle back and forth between start and end.		 * 		 * <p>The default value is 1 meaning tween from start to end; if set to		 * 2 or higher the tween returns, replays, and so on; if set to 0		 * (or Number.POSITIVE_INFINITY, which will result in a setting of 0		 * since the type is uint) the tween cycles indefinitely until stop() 		 * is called.</p>		 * 		 * <p>For cycles other than 1 you may set an alternate easing for 		 * return-cycles using easingOnCycle.</p>		 * 		 * @default 1		 * @see #easingOnCycle		 */		public function get cycles():uint {			return _cycles;		}		public function set cycles(value:uint):void {			if (_state==STOPPED)				_cycles = value;		}				/**		 * Optionally specify a different easing for each alternating cycle, if the		 * cycles property is set to a value other than 1. 		 * 		 * <p>For example an easing:easeOut with an easingOnCycle:easeIn will produce a 		 * natural-looking result.</p>		 * 		 * @see #cycles		 * @see #defaultEasing		 * @see #easing		 * @see #extraEasingParams		 */		public function get easingOnCycle():Function {			return _easing2;		}		public function set easingOnCycle(type:Function):void {			if (_state==STOPPED) {				try {					if (type(1,1,1,1) is Number) {						_easing2 = type;					}				}				catch (e:Error) {					throw e;				}			}		}				/**		 * Use to find out which cycle is currently playing.		 * @see #cycles		 */		public function get currentCycle():uint {			return _cyclesDone + 1;		}				//TODO:Implement useFrames option//		/**//		 * (This feature has not been written yet.)//		 *///		public function get useFrames():Boolean {//			return _useFrames;//		}//		public function set useFrames(value:Boolean):void {//			if (_state==STOPPED)//				_useFrames = value;//		}				/**		 * A number between 0 and 1 representing the current tween value.		 * 		 * <p>Use this number as a multiplier to apply values to targets 		 * across time.<p> 		 * 		 * <p>Here's an example of what an overridden update method might contain:</p>		 * <pre>		 * super.update(currentTime);		 * target[ propName ] = super.correctValue(startValue + change*_position);		 * </pre> 		 * @see #timePosition		 */		public function get position():Number {			return _position;		}				/**		 * A number indicating the current time position in the tween, 		 * spanning from negative-delay to 0 during the delay and		 * from 0 to tween duration during tween play. (Return values		 * are negative during delay, similar to skipTo.)		 * 		 * @see #position		 * @see #duration		 * @see #delay		 * @see #skipTo()		 */		public function get timePosition():Number {			if (_state==STOPPED)				return 0;			return Math.min(_duration, Math.max(-_delay, (getTimer()-_startTime) / 1000 / Math.max(0, timeMultiplier)) );		}						// -== Protected Properties ==-				/**		 * @private		 */		protected var _delay 			: Number = defaultDelay;		/**		 * @private		 */		protected var _duration 		: Number = defaultDuration;		/**		 * @private		 */		protected var _tweenDuration	: Number;		/**		 * @private		 */		protected var _easing 			: Function = defaultEasing;		/**		 * @private		 */		protected var _easeParams		: Array;		/**		 * @private		 */		protected var _extraEaseParams	: Array;		/**		 * @private		 */		protected var _cycles 			: uint = 1;		/**		 * @private		 */		protected var _cyclesDone		: uint;		/**		 * @private		 */		protected var _easing2	 		: Function;		/**		 * @private		 */		protected var _currentEasing	: Function;		/**		 * @private		 */		protected var _currentFrame		: uint;		/**		 * @private		 */		protected var _position			: Number;		/**		 * @private		 */		protected var _change			: Number;		/**		 * @private		 */		protected var _startTime		: Number;		/**		 * @private		 */		protected var _endTime 			: Number;		/**		 * @private		 */		protected var _pauseTime 		: Number;//		/**//		 * @private//		 *///		protected var _useFrames		: Boolean = false;		/**		 * @private		 */		protected var _callbacks		: Object = new Object(); // In tests, creating this object up front is more efficient.				// -== Public Methods ==-				/**		 * The inputs here are not a convention, subclasses should design		 * their own constructors appropriate to usage. They are provided		 * here primarily as a convenience for subclasses.		 */		public function LinearGo(	delay	 			: Number=NaN,									duration 			: Number=NaN,									easing 				: Function=null,									extraEasingParams	: Array=null,									cycles				: Number=NaN,									easingOnCycle		: Function=null,									useRelative			: Boolean=false,									useRounding			: Boolean=false,									pulseInterval		: Number=NaN ) {			if (!isNaN(delay)) this._delay = delay;			if (!isNaN(duration)) this._duration = duration;			if (easing!=null) this.easing = easing;			if (extraEasingParams) this._extraEaseParams = extraEasingParams;			if (!isNaN(cycles)) this._cycles = cycles;			if (easingOnCycle!=null) this._easing2 = easingOnCycle;			if (useRelative) this.useRelative = useRelative;			if (useRounding) this.useRounding = useRounding;			if (!isNaN(pulseInterval)) this._pulse = pulseInterval;		}				/**		 * Starts play for this LinearGo instance using GoEngine.		 * 		 * <p>CONVENTION ALERT: If <code>useRelative</code> is true, calculate tween values		 * relative to the target object's existing value as in the example below.</p>		 * 		 * <p>Most typically you should also store the tween's start and change values		 * for later use in <code>onUpdate</code>.</p>		 * 		 * <pre>		 * protected var _target : DisplayObject;		 * protected var _width : Number;		 * protected var _changeWidth : Number;		 * 		 * public function start():Boolean 		 * {		 *     if (!_target || !_width || isNaN(_width))		 *         return false;		 * 		 *     _startWidth = _target.width;		 * 		 *     if (useRelative) {		 *         _changeWidth = _width;		 *     } else {		 *         _changeWidth = (_width - _startWidth);		 *     }		 *     		 *     return (super.start());		 * }		 * </pre>		 * 		 * @return Successful addition of the item to GoEngine		 * 		 * @see GoItem#useRelative		 * @see #onUpdate()		 */		public function start() : Boolean {			stop(); // does nothing if already stopped.			if (GoEngine.addItem(this)==false)				return false;			reset();			_state = (_delay > 0 ? PLAYING_DELAY : PLAYING); // has to be set here since delay is not included in PlayableBase.			return true;		}				/**		 * Ends play for this LinearGo instance and dispatches a GoEvent.STOP		 * event if the tween is incomplete. This method does not typically 		 * require subclassing.		 * 		 * @return Successful removal of the item from GoEngine		 */		public function stop() : Boolean {			if (_state==STOPPED || GoEngine.removeItem(this)==false)				return false;			_state = STOPPED;			var completed:Boolean = (_position==_cyclesDone%2);			reset();			if (!completed) // otherwise a COMPLETE event was dispatched.				dispatch( GoEvent.STOP );			return true;		}		/**		 * Pauses play (including delay) for this LinearGo instance.		 * This method does not typically require subclassing.		 * 		 * @return Success		 * @see #resume()		 * @see org.goasap.GoEngine#setPaused GoEngine.setPaused()		 */		public function pause() : Boolean {			if (_state==STOPPED || _state==PAUSED)				return false;			_state = PAUSED;			_pauseTime = getTimer(); // This causes update() to skip processing.			return true;		}				/**		 * Resumes previously paused play, including delay.		 * This method does not typically require subclassing.		 * 		 * @return Success		 * @see #pause()		 * @see org.goasap.GoEngine#setPaused GoEngine.setPaused()		 */		public function resume() : Boolean {			if (_state != PAUSED)				return false;			var currentTime:Number = getTimer();			setStartTime(currentTime - (_pauseTime - _startTime), false, false); 			_pauseTime = NaN;			_state = (_startTime > currentTime ? PLAYING_DELAY : PLAYING);			return true;		}				/**		 * Skips to a point in the tween's duration and plays, from any state. 		 * This method does not typically require subclassing.		 * 		 * <p>There are several usages for this method:</p>		 * 		 * <ul>		 * <li>Pass 0 to <b>rewind</b> and restart the animation, with no delay.<br><br></li>		 * <li>Pass a number less than the tween's duration to <b>skip to</b> that point in 		 * the animation. Note that results will appear to vary based on easing style.<br><br></li>		 * <li>Pass the tween's duration value to <b>fast-forward and complete</b> the tween cycle.<br><br></li>		 * <li>Pass a <b>negative number to play a new delay</b> before restarting the tween. 		 * For example <code>tweenInstance.skipTo(-2);</code> will cause the tween to		 * delay for two seconds then begin the tween again. (Note that this does not		 * reset a cycles count in progress, it merely inserts a new delay prior to		 * resuming the current cycle.)</li>		 * </ul>		 * 		 * <p>If GoItem.timeMultiplier is set to a custom value, you should still pass a 		 * seconds value based on the tween's real duration setting.</p>		 * 		 * @param seconds	A number between zero and the tween's duration 		 * 					(plus delay, except during cycles higher than one).		 * @return Success		 * @see #timePosition		 */		public function skipTo(seconds : Number) : Boolean 		{			if (isNaN(seconds)) 				seconds = 0;			var currentTime:Number = getTimer();			var startTime:Number = (currentTime - (Math.min(seconds, _duration) * 1000 * Math.max(0, timeMultiplier)));			if (_state==STOPPED) {				if (start()==false) 					return false;				setStartTime( startTime, false, true );			}			else {				setStartTime( startTime, false, false );			}			_state = (_startTime > currentTime ? PLAYING_DELAY : PLAYING);			update(currentTime);			return true;		}				/**		 * An alternative to subscribing to events is to store callbacks. You can 		 * associate any number of callbacks with the primary GoEvent types START,		 * UPDATE, COMPLETE, and STOP (only fired if the tween is stopped before it 		 * completes).		 * 		 * <p>		 * Note that there is little difference between using callbacks and events.		 * Both are common techniques used in many various modern tweening APIs. Callbacks 		 * are slightly faster, but this won't normally be noticeable unless thousands of 		 * tweens are being run at once.		 * </p>		 * 		 * @param closure	A reference to a callback function		 * @param type		Any GoEvent type constant, the default is COMPLETE.		 * @see #removeCallback		 * @see org.goasap.events.GoEvent GoEvent		 */		public function addCallback(closure : Function, type : String=GoEvent.COMPLETE):void {			if (!_callbacks[ type ]) 				_callbacks[ type ] = new Array();			var a:Array = (_callbacks[ type ] as Array);			if (a.indexOf(closure)==-1)				a.push(closure);		}				/**		 * Removes a method closure previously stored using addCallback.		 * 		 * @param closure	A reference to a function		 * @param type		A GoEvent constant, default is COMPLETE.		 * @see #addCallback		 * @see org.goasap.events.GoEvent GoEvent		 */		public function removeCallback(closure : Function, type : String=GoEvent.COMPLETE):void {			var a:Array = (_callbacks[ type ] as Array);			if (a) 				while (a.indexOf(closure)>-1)					a.splice(a.indexOf(closure), 1);		}				/**		 * Performs tween calculations on GoEngine pulse.		 * 		 * <p>Subclass <code>onUpdate</code> instead of this method.		 * 		 * @param currentTime	Clock time for the current block of updates.		 * @see #onUpdate()		 */		override public function update(currentTime:Number) : void 		{			if (!_startTime)				setStartTime(currentTime, true, true);						// no updates during delay or pause.			if (_startTime > currentTime || _state == PAUSED)				return;						// Set _position and determine update type			var type:String;			if (currentTime >= _endTime) {				_cyclesDone++;				_position = _cyclesDone % 2;				if (_cyclesDone!=_cycles || _cycles==0) {					_change = -_change;					_startTime = NaN;					type = GoEvent.UPDATE;				} 				else {					type = GoEvent.COMPLETE;				}			}			else {				type = (_currentFrame==0 ? GoEvent.START : GoEvent.UPDATE);				_currentFrame++;				_easeParams[0] = (currentTime - _startTime);				_position = _currentEasing.apply(null, _easeParams);			}			// Run onUpdate then dispatch events (START just before first UPDATE, COMPLETE just after last)			onUpdate(type);			if (type==GoEvent.START) {				_state = PLAYING;				dispatch(GoEvent.START);			}			dispatch(GoEvent.UPDATE);			if (type==GoEvent.COMPLETE) {				stop();				dispatch(GoEvent.COMPLETE);			}		}				// -== Protected Methods ==-				/**		 * Subclass this method (instead of the update method) for simplicity. 		 * 		 * <p>Use this method to manipulate targets based on the current _position 		 * setting, which is a 0-1 multiplier precalculated to the tween's position		 * based on its easing style and the current time in the tween.</p> 		 * 		 * <p>CONVENTION ALERT: To implement the Go convention <code>useRounding</code>,		 * always call GoItem's <code>correctValue()</code> method on each calculated 		 * tween value before you apply it to a target. This corrects NaN to 0 and 		 * rounds the value if <code>useRounding</code> is true.</p>		 * 		 * Example:		 * <pre>		 * override protected function onUpdate(type:String):void		 * {		 *     target[ propName ] = super.correctValue(startValue + change*_position);		 * }		 * </pre>		 * 		 * @param type	A constant from the class GoEvent: START, UPDATE, or COMPLETE.		 * @see GoItem#correctValue()		 * @see GoItem#useRounding		 * @see #update()		 */		protected function onUpdate(type : String) : void 		{			// Subclass this method and start to implement your tween class.		}				/**		 * @private		 * Internal setup routine used by start() and other methods.		 * 		 * @param time			Tween start time based on getTimer		 * @param includeDelay	Whether to calculate the delay into the start and end times		 */		protected function setStartTime(time : Number, includeDelay:Boolean = false, runSetup:Boolean=true) : void 		{			_startTime = time;			_tweenDuration = (_duration * 1000 * Math.max(0, timeMultiplier));			_endTime = _startTime + _tweenDuration;			if (includeDelay) {				_startTime += (_delay * 1000 * Math.max(0, timeMultiplier));				_endTime += (_delay * 1000 * Math.max(0, timeMultiplier));			}						if (runSetup) {				if (_position!=0 && _position!=1) // if _position is not 0 or 1, setup should not be called.					throw new Error("LinearGo.setStartTime > if (runSetup)... bad _position="+_position);				// Store reused parameters which reduces object-creation.				_easeParams = new Array(0, _position, _change, _tweenDuration);				_currentEasing = ( _cyclesDone%2==1 && _easing2!=null   // _cyclesDone should be udpated prior to calling setup.									? _easing2									: _easing );				if (_extraEaseParams)					_easeParams = _easeParams.concat(_extraEaseParams);			}		}				/**		 * @private		 * Internal, dispatches events and executes callbacks of any pre-verified type.		 *  		 * @param type	Verified in addCallback, not in this method.		 * @see #org.goasap.events.GoEvent GoEvent		 */		protected function dispatch(type:String):void 		{			var a:Array = (_callbacks[ type ] as Array);			if (a)				for each (var callback:Function in a)					callback();			if (hasEventListener(type))				dispatchEvent(new GoEvent( type ));		}				/**		 * @private		 */		protected function reset() : void {			_position = 0;			_change = 1;			_cyclesDone = 0;			_currentFrame = 0;			_pauseTime = NaN;			_startTime = NaN;		}	}}