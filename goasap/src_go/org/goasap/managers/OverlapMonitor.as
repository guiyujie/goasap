/** * Copyright (c) 2007 Moses Gunesch *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */package org.goasap.managers {	import flash.utils.Dictionary;		import org.goasap.interfaces.IManageable;	import org.goasap.interfaces.IManager;		/**
	 * Calls <code>releaseHandling()</code> on currently-active items when 	 * property-handling overlap is detected (like two tweens trying to set 	 * the same sprite's x property), as new items are added to GoEngine. 	 * 	 * <p>To activate this manager call the following line one time:</p>	 * <pre>GoEngine.addManager( new OverlapMonitor() );</pre>	 * 	 * {In the game of Go, a superko is a rule that prevents a potentially	 *  infinite competition - ko - over the same space.}	 *  	 * @see org.goasap.interfaces.IManager IManager	 * @see org.goasap.interfaces.IManageable IManageable	 * @see org.goasap.GoEngine GoEngine	 *  	 * @author Moses Gunesch
	 */
	public class OverlapMonitor implements IManager	{		/**		 * This manager uses a Dictionary with target objects as the index		 * values and an Array of handlers currently handling the target as		 * the stored values. Targets are indexed because they are the primary 		 * point of overlap to check first.		 */		protected var handlers : Dictionary = new Dictionary(true);				/**		 * Sets an IManageable as reserving its target/property combinations.		 * 		 * @param handler		IManageable to reserve		 */		public function reserve(handler:IManageable):void		{			var targs:Array = handler.getActiveTargets();			var props:Array = handler.getActiveProperties();						if (!targs || !props)				return;			if (targs.length==0 || props.length==0)				return;						// The dictionary is keyed by animation target objects, the most primary point of potential overlap.			// Cycle through the targets handled by the incoming handler (often there's only one), 			// then inspect the handlers currently assigned to determine overlap.			for each (var target:Object in targs)			{				// Case: incoming handler is the only one working with this target at this time.				if (!handlers[ target ]) {					handlers[ target ] = new Array(handler);					continue; 				}								// There is a matching target in the Dictionary. Each entry in the dictionary is an Array of 				// IManageable instances currently handling that target.				var handlersForTarget:Array = (handlers[ target ] as Array);								// Duplicate entries are not allowed in the handler lists. (Really we should return out here 				// since targets are not supposed to change during item play, but continue just to be sure.)				if (handlersForTarget.indexOf(handler) > -1)					continue;								// Leave first so resulting release() doesn't destroy the array before we write to it.				handlersForTarget.push( handler );								// Test all properties being handled on this target against existing handlers for this target.				// If an overlap is reported, release the existing handler which is then responsible for stopping itself.				for each (var handlerToTest:IManageable in handlersForTarget) {					if (handlerToTest!=handler)						if (handlerToTest.isHandling(props) == true)							handlerToTest.releaseHandling();				}			}		}				/**		 * Releases an IManageable from being monitored. Does not call releaseHandling() on instances,		 * since this method is called after an instance has already removed itself from the engine.		 * 		 * @param handler	The IManageable to remove from internal lists.		 */		public function release(handler:IManageable):void		{			for (var target:Object in handlers) {				var handlerList:Array = (handlers[target] as Array);				// Array entries are unique so we only have to remove one.				var i:int =(handlerList.indexOf(handler));				if (i>-1) {					handlerList.splice(i, 1);					if (handlerList.length==0)						delete handlers[ target ];				}			}		}	}}