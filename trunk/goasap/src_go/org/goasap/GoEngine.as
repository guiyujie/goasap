/** * Copyright (c) 2007 Moses Gunesch *  * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */package org.goasap {	import flash.display.Sprite;	import flash.events.Event;	import flash.events.TimerEvent;	import flash.utils.Dictionary;	import flash.utils.Timer;	import flash.utils.getTimer;		import org.goasap.interfaces.IManageable;	import org.goasap.interfaces.IManager;	import org.goasap.interfaces.IUpdatable;		/**	 * Provides <code>update</code> calls to <code>IUpdatable</code> instances on their specified <code>pulseInterval</code>.	 * 	 * <p><b>Using these Docs</b></p>	 * 	 * <p><i>Protected methods and properties have been excluded in almost all 	 * cases, but are documented in the classes. Exceptions include key protected	 * methods or properties that are integral for writing subclasses or understanding 	 * the basic mechanics of the system. Many Go classes can be used as is without 	 * subclassing, so the documentation offers an uncluttered view of their public	 * usage.</i></p>	 * 	 * <p><b>Introduction to Go</b></p>	 * 	 * <p>The Go ActionScript Animation Platform ("GOASAP") is a lightweight, portable 	 * set of generic base classes for buliding AS3 animation tools. It provides structure 	 * and core functionality, but does not define the specifics of animation-handling 	 * classes like tweens.</p>	 * 	 * <p><i>Important: Store your custom Go classes in a package bearing your 	 * own classpath, not in the core package! This will help avoid confusion 	 * with other authors' work.</i></p>	 * 	 * 	 * <p><b>GoEngine</b></p>	 * 	 * <p>GoEngine sits at the center of the Go system, and along with the IUpdatable 	 * interface is the only required element for using Go. GoEngine references two other 	 * interfaces for adding system-wide managers, IManager and IManageable.	 * All other classes in the go package are merely one suggestion of how a 	 * system could be structured within Go, and may be considered optional 	 * elements. To create an API using the provided classes, you simply need 	 * to extend the item classes LinearGo and PhysicsGo to create animation items.</p>	 * 	 * <p>GoEngine serves two purposes: first, it keeps a large system efficient 	 * by stacking and running updates on blocks of items. Note that any IUpdatable 	 * instance may specify its own pulseInterval; items with matching pulses 	 * are grouped into queues for efficiency. Its second purpose is centralization. 	 * By using a single hub for pulse-driven items of all types, management classes 	 * can be attached to GoEngine to run processes across items. This is done voluntarily 	 * by the end-user with <code>addManager</code>, which keeps management entirely 	 * compile-optional and extensible.</p>	 * 	 * <p>You may modify any class in the go package to suit your project's needs.</p>	 *  	 * <p>Go is a community initiative led by Moses Gunesch at 	 * <a href="http://www.mosessupposes.com/">MosesSupposes.com</a>. Please visit the 	 * <a href="http://www.goasap.org/">Go website</a> for more information.</p>	 * 	 * <p></i>{In the game of Go, the wooden playing board, or Goban, features a grid	 *  on which black & white go-ishi stones are laid at its intersections.}</i></p>	 * 	 * @author Moses Gunesch	 */	public class GoEngine 	{		// -== Constants ==-				public static const INFO:String = "Go 0.3.0 (c) Moses Gunesch, MIT Licensed.";				// -== Settable Class Defaults ==-				/**		 * A pulseInterval that runs on the player's natural framerate, 		 * which is often most efficient.		 */		public static const ENTER_FRAME	: int = -1;		// -== Protected Properties ==-				private static var items : Dictionary = new Dictionary(false);		private static var timers : Dictionary = new Dictionary(false);		private static var timerCounts : Dictionary = new Dictionary(false);		private static var pulseSprite : Sprite;		private static var paused : Boolean = false;		private static var itemCount : uint = 0;		private static var managers : Dictionary = new Dictionary(false);				// -== Public Class Methods ==-				/**		 * Enables the extending of this class' functionality with a tight		 * coupling to an IManager. 		 * 		 * <p>Tight coupling is crucial in such a time-sensitive context; 		 * standard events are too asynchronous. All items that implement 		 * IManageable are reported to registered managers as they add and 		 * remove themselves from GoEngine.</p>		 * 		 * @see #removeManager()		 */		public static function addManager( instance:IManager ):void		{			managers[ instance ] = 1; // Dictionary avoids duplication		}				/**		 * Unregisters any manager set in <code>addManager</code>.		 * 		 * @see #addManager()		 */		public static function removeManager( instance:IManager ):void		{			delete managers[ instance ];		}				/**		 * Test whether an item is currently stored and being updated by the engine.		 * 		 * @param item		Any object implementing IUpdatable		 * @return			Whether the IUpdatable is in the engine		 */		public static function hasItem( item:IUpdatable ):Boolean		{			return (isNaN(getPulse(item))==false);		}				/**		 * Adds an IUpdatable instance to an update-queue corresponding to		 * the item's pulseInterval property.		 * 		 * @param item		Any object implementing IUpdatable that wishes 		 * 					to receive update calls on a pulse.		 * 							 * @return			Success		 * @see #removeItem()		 */		public static function addItem( item:IUpdatable ):Boolean		{			removeItem(item);			var interval:int = item.pulseInterval;			if (!items[ interval ]) {				// Create a itemlist for each pulse. Grouping items in a list keeps update cycles efficient.				items[ interval ] = new Array();			}			(items[ interval ] as Array).push(item);			addPulse(interval);			itemCount++;						// Report IManageable instances to registered managers			if (item is IManageable) {				for (var manager:Object in managers)					(manager as IManager).reserve( item as IManageable );			}			return true;		}				/**		 * Removes an item from the queue and removes its pulse timer if		 * the queue is depleted.		 * 		 * @param item		Any IUpdatable previously added that wishes 		 * 					to stop receiving update calls.		 * 							 * @return			Success		 * @see #addItem()		 */		public static function removeItem( item:IUpdatable ):Boolean		{			var interval:Number = getPulse(item);			if (isNaN(interval))				return false;						var list:Array = (items[interval] as Array);			list.splice( list.indexOf(item), 1 ); // indexOf is pre-verified by getPulse call			if (list.length==0)				delete items[interval];			GoEngine.removePulse(interval);			itemCount--;						// Report IManageable item removal to registered managers.			if (item is IManageable) {				for (var manager:Object in managers)					(manager as IManager).release( item as IManageable );			}			return true;		}				/**		 * Removes all items and resets the engine, 		 * or removes just items running on a specific pulse.		 * 		 * @param pulseInterval		Optionally filter by a specific pulse 		 * 							such as ENTER_FRAME or a number of milliseconds.		 * @see #removeItem()		 */		public static function clear(pulseInterval:Number = NaN) : uint		{			var count:uint = 0;			var all:Boolean = (isNaN(pulseInterval));			for (var pulse:Object in items) { 				if (all || Number(pulse)==pulseInterval) {					var list:Array = (items[pulse] as Array);					for each (var item:IUpdatable in list)						if (removeItem(item)==true)							count++;				}			}			return count;		}				/**		 * Retrieves number of active items in the engine 		 * or active items running on a specific pulse.		 * 		 * @param pulseInterval		Optionally filter by a specific pulseInterval		 *							such as ENTER_FRAME or a number of milliseconds.		 * 		 * @return					Number of active items in the Engine.		 */		public static function getCount(pulseInterval:Number = NaN) : uint		{			if (isNaN(pulseInterval))				return itemCount;						var list:Array = (items[pulseInterval] as Array);			if (list)				return list.length;						return 0;		}				/**		 * @return			The paused state of engine.		 * @see #setPaused()		 */		public static function getPaused() : Boolean {			return paused;		}				/**		 * Pauses or resumes all animation globally by suspending processing.		 * 		 * @param pause		Pass false to resume if currently paused.		 * @see #getPaused()		 */		public static function setPaused(pause:Boolean=true) : void		{			if (paused==pause) return;			paused = pause;			for (var pulse:Object in timers) {				if (pulse==ENTER_FRAME) {					if (paused)						pulseSprite.removeEventListener(Event.ENTER_FRAME, update);					else						pulseSprite.addEventListener(Event.ENTER_FRAME, update);				}				else {					if (paused)						Timer( timers[ pulse ] ).stop();					else						Timer( timers[ pulse ] ).start();				}			}		}				// -== Private Class Methods ==-				/**		 * Executes the update queue corresponding to the dispatcher's interval.		 * 		 * @param event			TimerEvent or Sprite ENTER_FRAME Event		 */		private static function update(event:Event) : void 		{			var currentTime:Number = getTimer();			var pulse:int = (event is TimerEvent ? ( event.target as Timer ).delay : ENTER_FRAME);			var list:Array = (items[ pulse ] as Array);			for each (var item:IUpdatable in list) {				item.update(currentTime);			}		}				/**		 * Creates new timers when a previously unused interval is specified,		 * and tracks the number of items associated with that interval.		 * 		 * @param pulse			The pulseInterval requested		 */		private static function addPulse(pulse : int) : void		{			if (!timerCounts[ pulse ]) {				timerCounts[ pulse ] = 0;				if (pulse==ENTER_FRAME) {					pulseSprite = new Sprite();					pulseSprite.addEventListener(Event.ENTER_FRAME, update);				}				else {					timers[ pulse ] = new Timer(pulse);					Timer( timers[ pulse ] ).addEventListener(TimerEvent.TIMER, update);					Timer( timers[ pulse ] ).start();				}			}			timerCounts[ pulse ] += 1;		}				/**		 * Tracks whether a removed item was the last one using a timer 		 * and if so, removes that timer.		 * 		 * @param pulse			The pulseInterval corresponding to an item being removed.		 */		private static function removePulse(pulse : int) : void		{			if (--timerCounts[ pulse ] == 0) {				if (pulse==ENTER_FRAME) {					pulseSprite.removeEventListener(Event.ENTER_FRAME, update);					pulseSprite = null;				}				else {					Timer( timers[ pulse ] ).stop();					Timer( timers[ pulse ] ).removeEventListener(TimerEvent.TIMER, update);				}				delete timers[ pulse ];				delete timerCounts[ pulse ];			}		}				/**		 * Internal search method that determines whether an item is stored in the engine		 * and if so, which pulse key it is stored under.		 * @param item		The item to search on		 * @return			The pulse key for the items Dictionary or NaN if not located.		 */		private static function getPulse( item:IUpdatable ) : Number		{			try {				// Fast return if item's pulseInterval hasn't changed since it was added				if ((items[item.pulseInterval] as Array).indexOf(item) > -1) 					return item.pulseInterval;			}			catch (e:Error) {				// A search is necessary				for (var pulse:String in items) 					if((items[Number(pulse)] as Array).indexOf(item) > -1) 						return Number(pulse);			}			return NaN;		}	}}